Student: Diego Rafael Moreno Ferrer
SUID: rmferrer
email: rmferrer@cs.stanford.edu

CS144 
README for Lab 2

Recall that the functionality in the assignment can be divided into two separate entities with
two separate state machines. 1) The CLIENT is responsible for reading data from conn_input,
putting it into packets, sending/retransmitting it via conn_sendpkt and receiving/processing 
the acks sent by the other side. 2) The SERVER is concerned with receiving data, flushing it 
to conn_output and sending acks to the other side. So CLIENT sends data and receives acks and 
SERVER receives data and sends acks. 

Most of the logic/functions can be divided along the lines of client functionality and server
functionality. There are also other utility functions shared by both the client and the server
such as prepare_for_transmission (which takes any type of outgoing packet and puts it in
network byte order and computes its checksum), is_packet_corrupted,
convert_packet_to_host_byte_order, convert_packet_to_network_byte_order, compute_checksum, etc. This functions are explained in the internal documentation in reliable.c.


Discussion of Client Side:

The following state is kept in the rel_t structure of the connection for the client:
 

struct client_state {
  /* state for linked list of packets in flight */ 
  packet_record_t *headPacketsInFlightList;
  packet_record_t *tailPacketsInFlightList; 
  int numPacketsInFlight;
  int isEOFinFlight;
  uint32_t EOFseqno;
  int isPartialInFlight;
  uint32_t partialSeqno;
  int numPartialsInFlight; 
  int windowSize; /* Send Window Size (SWS) */
  uint32_t lastAckedSeqno; /* LAR */
  uint32_t lastSentSeqno; /* LSS; sender must maintain LSS - LAR <= SWS */
  
  /* Buffer in case Nagle forces to buffer a partial packet */
  uint8_t partialPayloadBuffer[PAYLOAD_MAX_SIZE]; /* store only the packet's payload */
  uint16_t bufferLength; /* how many bytes used in the buffer */

  int isFinished; /* has client finished sending data? (i.e. sent and received an ack for EOF packet)*/
};
typedef struct client_state client_state_t; 


The client maintains linked list of packets in flight and a few other fields to keep track of its state. 
It also has helper functions like is_partial_packet_in_flight, is_client_finished, is_EOF_in_flight, 
is_client_window_full, etc. which help know which state the client is in. When reading from the input the 
client will check if the window is not full, if an EOF is not in flight and if it has not finished
transmitting and will only create a packet then. The packet will be created from the input or from a buffer. 
Such buffer holds partial payloads in case a partial packet is in flight (by Nagle we cannot send
partial payloads) and will be used to create a new packet when input is available. If a partial packet
is in flight the client will send the created packet has full payload and will buffer it in partialPayloadBuffer otherwise. If no partial packet is in flight the packet will be sent and the state will
be updated by adding the packet to the in flight list.
 

Discussion of Server Side:

The following state is kept in the rel_t structure of the connection for the server.
  

struct server_state {
  /* state for linked list of packets in window that were received and are being buffered */ 
  packet_record_t *headReceiveWindowList;
  int windowSize; /* Receive window size (RWS) */
  int numPacketsBuffered;
  int lastAcceptableSeqno; /* end of window */
  int lastReceivedSeqno; /* seqno of the last packet delivered to application */
  int isFinished; /* has server finished receiving data? (i.e. received and outputed an EOF packet)*/
};
typedef struct server_state server_state_t; 


The server side keeps a list of packets received that are within its window, i.e. between 
lastReceivedSeqno + 1 and lastAcceptableSeqno. Packets with seqnos before this range will be acked
and with seqnos after will be discarded. Once the server has a complete contiguous sequence of 
packets starting at lastReceivedSeqno + 1 it will try to flush them to the output using flush_receive_window_buffer_to_output. This function basically takes all the packets in the receive
window list that can be flushed, tries to flush them to the output and upon sucessfull flushing
it acks them back. 

Some other considerations in the code: The rel_recvpkt and rel_destroy functions are functions
both used by the client and server sides (rel_read and rel_timer is client only, and
rel_output is server only). 

The rel_recvpkt function will take packets for both the client and the server and will check
the packet for corruption, dropping it if it is corrupted, will convert it to host byte order,
and depending on whether it was an ack_only packet or a data packet it will then invoke code
belonging to the client or server to deal with the packet. The function process_data_packet
handles data packets for the server side and checks if the packet has already been seen in
which case it sends an ack or it it has not been seen and it the next in sequence it
processes it and sends an ack if flushed. The function process_ack takes either an ack_only
packet or a data packet and process the ack number in it. 

The rel_destroy function is called either by the client or the server. It is called by the
client if it receives an an ack for the last EOF packet it sent and the server side is
already in SERVER_FINISHED state. It is called by the server in case it receives an in
sequence data packet that has no payload (i.e. and EOF packet) and if the client side is already in CLIENT_FINISHED (after calling conn_output with a zero length of course).
